/**
 * Shared utility functions for Supermemory integration
 * Used by roleplay-memory system
 */

/**
 * Format a message with embedded scene
 * CRITICAL: Explicitly states speaker to help AI knowledge extraction understand who "I" refers to
 * @param characterName - Character who spoke
 * @param content - Message content
 * @param scene - Current scene (e.g., "Classroom Morning Day 1")
 * @returns Formatted message string
 */
export function formatMessageWithScene(
  characterName: string,
  content: string,
  scene: string
): string {
  return `This message was generated by ${characterName} (speaker):\n${content}\nScene: ${scene}`
}


/**
 * Build a container tag from session ID and resource ID
 * Uses '::' delimiter to avoid conflicts with UUIDs containing hyphens
 * @param sessionId - Session identifier
 * @param resourceId - Character ID or "world"
 * @returns Container tag string
 */
export function buildContainerTag(
  sessionId: string,
  resourceId: string
): string {
  return `${sessionId}::${resourceId}`
}

/**
 * Validate a character container tag format
 * @param tag - Container tag to validate
 * @returns True if valid character container format
 */
export function validateCharacterContainer(tag: string): boolean {
  // Must have format: {sessionId}::{characterId}
  // Must NOT end with "::world"
  return tag.includes('::') && !tag.endsWith('::world')
}

/**
 * Validate a world container tag format
 * @param tag - Container tag to validate
 * @returns True if valid world container format
 */
export function validateWorldContainer(tag: string): boolean {
  // Must end with "::world"
  return tag.endsWith('::world')
}

/**
 * Validate any container tag
 * @param tag - Container tag to validate
 * @returns True if valid container format (character or world)
 */
export function validateContainerTag(tag: string): boolean {
  return validateCharacterContainer(tag) || validateWorldContainer(tag)
}

/**
 * Extract actual message content from enriched memory format
 *
 * Enriched format contains:
 * - ###Scene###\nScene name
 * - ###Message###\nThis message was generated by CharName (speaker):\nCONTENT
 * - ###World context###\nContext (optional)
 *
 * This function extracts ONLY the message content for verbatim quotation.
 *
 * @param enrichedMemory - Full enriched memory string from storage
 * @returns Array of extracted message contents (one per message section found)
 *
 * @example
 * Input: "###Message###\nThis message was generated by Yui (speaker):\nHello there!"
 * Output: ["Hello there!"]
 */
export function extractMessageContent(enrichedMemory: string): string[] {
  const messages: string[] = [];

  // NEW FORMAT: "This message was generated by {name} (speaker):\n{content}"
  // Match everything after the speaker line until the next section or end
  const newFormatPattern = /This message was generated by ([^(]+) \(speaker\):\s*\n(.+?)(?=\n(?:Scene:|###|\n)|$)/gs;

  let match;
  while ((match = newFormatPattern.exec(enrichedMemory)) !== null) {
    const content = match[2]?.trim();
    if (content) {
      messages.push(content);
    }
  }

  // BACKWARD COMPATIBILITY: Old format "Message: {name}: {content}"
  // Only use if new format didn't match anything
  if (messages.length === 0) {
    const oldMessagePattern = /Message:\s*([^:]+):\s*(.+?)(?:\s+(?:GameTime:\s*\d+\s+\w+|Scene:))?(?:\n|$)/g;
    while ((match = oldMessagePattern.exec(enrichedMemory)) !== null) {
      const content = match[2]?.trim();
      if (content) {
        messages.push(content);
      }
    }
  }

  return messages;
}

/**
 * Parse verbatim memories to extract quotable message content
 *
 * Takes array of enriched memory strings and extracts only the actual
 * message content that can be quoted directly, removing all metadata.
 *
 * @param verbatimMemories - Array of enriched memory strings from v3 search
 * @returns Array of clean message contents suitable for direct quotation
 */
export function parseVerbatimMemories(verbatimMemories: string[]): string[] {
  const allMessages: string[] = [];

  for (const memory of verbatimMemories) {
    const extracted = extractMessageContent(memory);
    allMessages.push(...extracted);
  }

  return allMessages;
}
