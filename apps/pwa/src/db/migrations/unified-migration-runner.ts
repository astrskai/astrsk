import { Drizzle } from "@/db/drizzle";
import { sql } from "drizzle-orm";
import migrations from "@/db/migrations/migrations.json";
import { logger } from "@/shared/lib/logger";

/**
 * Unified Migration Runner
 *
 * Runs both SQL and TypeScript migrations in timestamp order.
 *
 * How it works:
 * 1. SQL migrations come from migrations.json (generated by Drizzle)
 * 2. TypeScript migrations are registered below
 * 3. Both are merged and sorted by timestamp (folderMillis for SQL, filename timestamp for TS)
 * 4. Migrations are executed in chronological order
 * 5. Execution is tracked in two tables:
 *    - drizzle.__drizzle_migrations (SQL migrations - managed by Drizzle)
 *    - public.__data_migrations (TypeScript migrations - managed by us)
 *
 * Migration Types:
 * - SQL migrations: Schema changes (CREATE TABLE, ALTER TABLE, etc.)
 * - TypeScript migrations: Data migrations (copying, transforming data)
 *
 * Order: Determined by timestamp
 * - SQL: folderMillis field in migrations.json
 * - TypeScript: filename prefix (YYYYMMDDHHMMSS_name.ts)
 */

const DRIZZLE_MIGRATION_SCHEMA = "drizzle";
const DRIZZLE_MIGRATION_TABLE = "__drizzle_migrations";
const DATA_MIGRATION_TABLE = "__data_migrations";

interface MigrationRecord {
  hash?: string; // SQL migrations have hash
  filename: string;
  type: "sql" | "typescript";
  timestamp: number; // Unix timestamp in milliseconds
  executed_at?: Date;
}

/**
 * TypeScript migrations registry
 * Import and register all TypeScript migrations here
 *
 * IMPORTANT: Filename must start with YYYYMMDDHHMMSS timestamp
 */
import { migrateCardsData } from "./20251117050000_migrate_cards_data";
import { populateAgentFlowId } from "./20251117115504_populate_agent_flow_id";
import { migrateSessionsToLocalResources } from "./20251117115505_migrate_sessions_to_local_resources";
import { migrateBackgroundsToSessions } from "./20251121031122_migrate_backgrounds_to_sessions";

const typescriptMigrations: Record<string, () => Promise<void>> = {
  "20251117050000_migrate_cards_data.ts": migrateCardsData,
  "20251117115504_populate_agent_flow_id.ts": populateAgentFlowId,
  "20251117115505_migrate_sessions_to_local_resources.ts":
    migrateSessionsToLocalResources,
  "20251121031122_migrate_backgrounds_to_sessions.ts":
    migrateBackgroundsToSessions,
};

/**
 * Ensure migration tracking schemas and tables exist
 */
async function ensureMigrationInfrastructure(db: any) {
  // Create drizzle schema for SQL migrations
  await db.execute(
    sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(DRIZZLE_MIGRATION_SCHEMA)}`,
  );

  // Create drizzle migration table for SQL migrations
  await db.execute(sql`
    CREATE TABLE IF NOT EXISTS ${sql.identifier(DRIZZLE_MIGRATION_SCHEMA)}.${sql.identifier(DRIZZLE_MIGRATION_TABLE)} (
      hash TEXT PRIMARY KEY,
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Create data migration table for TypeScript migrations
  await db.execute(sql`
    CREATE TABLE IF NOT EXISTS ${sql.identifier(DATA_MIGRATION_TABLE)} (
      id SERIAL PRIMARY KEY,
      filename TEXT NOT NULL UNIQUE,
      executed_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
}

/**
 * Get hashes of executed SQL migrations
 */
async function getExecutedSqlMigrations(db: any): Promise<Set<string>> {
  const result = await db.execute(sql`
    SELECT hash FROM ${sql.identifier(DRIZZLE_MIGRATION_SCHEMA)}.${sql.identifier(DRIZZLE_MIGRATION_TABLE)}
  `);
  return new Set(result.rows.map((row: any) => row.hash));
}

/**
 * Get filenames of executed TypeScript migrations
 */
async function getExecutedTypescriptMigrations(db: any): Promise<Set<string>> {
  const result = await db.execute(sql`
    SELECT filename FROM ${sql.identifier(DATA_MIGRATION_TABLE)}
  `);
  return new Set(result.rows.map((row: any) => row.filename));
}

/**
 * Mark SQL migration as executed
 */
async function markSqlMigrationExecuted(db: any, hash: string) {
  await db.execute(sql`
    INSERT INTO ${sql.identifier(DRIZZLE_MIGRATION_SCHEMA)}.${sql.identifier(DRIZZLE_MIGRATION_TABLE)} (hash, created_at)
    VALUES (${hash}, CURRENT_TIMESTAMP)
    ON CONFLICT (hash) DO NOTHING
  `);
}

/**
 * Mark TypeScript migration as executed
 */
async function markTypescriptMigrationExecuted(db: any, filename: string) {
  await db.execute(sql`
    INSERT INTO ${sql.identifier(DATA_MIGRATION_TABLE)} (filename)
    VALUES (${filename})
    ON CONFLICT (filename) DO NOTHING
  `);
}

/**
 * Extract timestamp from TypeScript migration filename (YYYYMMDDHHMMSS)
 * Converts to milliseconds for comparison with SQL migration folderMillis
 */
function filenameTimestampToMillis(filename: string): number {
  const match = filename.match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/);
  if (!match) {
    logger.error(`Invalid migration filename format: ${filename}`);
    return 0;
  }

  const [, year, month, day, hour, minute, second] = match;
  const date = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}Z`);
  return date.getTime();
}

/**
 * Check if there are pending migrations (SQL or TypeScript)
 * Returns true if migrations need to be run
 */
export async function hasPendingMigrations(): Promise<boolean> {
  try {
    const db = await Drizzle.getInstance();

    // Ensure migration infrastructure exists
    await ensureMigrationInfrastructure(db);

    // Get already-executed migrations
    const executedSqlHashes = await getExecutedSqlMigrations(db);
    const executedTsFilenames = await getExecutedTypescriptMigrations(db);

    // Check SQL migrations
    for (const migration of migrations) {
      if (!executedSqlHashes.has(migration.hash)) {
        return true;
      }
    }

    // Check TypeScript migrations
    for (const filename of Object.keys(typescriptMigrations)) {
      if (!executedTsFilenames.has(filename)) {
        return true;
      }
    }

    return false;
  } catch (error) {
    // If any error occurs, assume migrations are needed (safe default)
    logger.error(
      "‚ö†Ô∏è Error checking pending migrations, will run migrations:",
      error,
    );
    return true;
  }
}

/**
 * Progress callback type for migration UI reporting
 */
type OnProgress = (
  stepId: string,
  status: "start" | "success" | "warning" | "error",
  error?: string,
) => void;

/**
 * Detailed migration error information
 */
export interface MigrationErrorDetails {
  migrationHash?: string;
  migrationFilename: string;
  migrationType: "sql" | "typescript";
  timestamp: string;
  failedQuery?: string;
  errorMessage: string;
  errorStack?: string;
}

/**
 * Store for last migration error (accessible from UI for recovery)
 */
let lastMigrationError: MigrationErrorDetails | null = null;

export function getLastMigrationError(): MigrationErrorDetails | null {
  return lastMigrationError;
}

/**
 * Run all migrations in timestamp order
 *
 * This function:
 * 1. Reads SQL migrations from migrations.json
 * 2. Reads TypeScript migrations from registry
 * 3. Merges and sorts by timestamp (folderMillis for SQL, filename for TS)
 * 4. Executes in chronological order
 * 5. Tracks execution in separate tables
 *
 * @param onProgress - Optional callback for UI progress reporting
 */
export async function runUnifiedMigrations(
  onProgress?: OnProgress,
): Promise<void> {
  logger.debug("üîÑ Starting unified migrations (SQL + TypeScript)...\n");

  // Step: Initialize database
  onProgress?.("database-init", "start");
  const db = await Drizzle.getInstance();
  onProgress?.("database-init", "success");

  // Step: Setup migration schema
  onProgress?.("migration-schema", "start");
  await ensureMigrationInfrastructure(db);
  onProgress?.("migration-schema", "success");

  // Step: Check pending migrations
  onProgress?.("check-migrations", "start");
  const executedSqlHashes = await getExecutedSqlMigrations(db);
  const executedTsFilenames = await getExecutedTypescriptMigrations(db);

  // Build unified migration list
  const allMigrations: MigrationRecord[] = [];

  // Add SQL migrations from migrations.json
  for (const migration of migrations) {
    allMigrations.push({
      hash: migration.hash,
      filename: `${migration.hash}.sql`,
      type: "sql",
      timestamp: migration.folderMillis,
    });
  }

  // Add TypeScript migrations from registry
  for (const filename of Object.keys(typescriptMigrations)) {
    allMigrations.push({
      filename,
      type: "typescript",
      timestamp: filenameTimestampToMillis(filename),
    });
  }

  // Sort by timestamp
  allMigrations.sort((a, b) => a.timestamp - b.timestamp);

  // Filter to pending migrations only
  const pendingMigrations = allMigrations.filter((migration) => {
    if (migration.type === "sql") {
      return !executedSqlHashes.has(migration.hash!);
    } else {
      return !executedTsFilenames.has(migration.filename);
    }
  });
  onProgress?.("check-migrations", "success");

  if (pendingMigrations.length === 0) {
    logger.debug("‚ú® No pending migrations found.\n");
    onProgress?.("run-migrations", "start");
    onProgress?.("run-migrations", "success");
    return;
  }

  logger.debug(`üì¶ Found ${pendingMigrations.length} pending migrations\n`);

  // Step: Run migrations
  onProgress?.("run-migrations", "start");

  // Execute pending migrations in order
  let sqlCount = 0;
  let tsCount = 0;

  for (const migration of pendingMigrations) {
    const timestamp = new Date(migration.timestamp).toISOString();

    if (migration.type === "sql") {
      logger.debug(`‚ö° [${timestamp}] Executing SQL: ${migration.hash}`);
      let currentQuery: string | undefined;
      try {
        // Find migration in migrations.json and execute SQL
        const sqlMigration = migrations.find((m) => m.hash === migration.hash);
        if (!sqlMigration) {
          throw new Error(`SQL migration not found: ${migration.hash}`);
        }

        // Execute each SQL statement
        for (const sqlStatement of sqlMigration.sql) {
          currentQuery = sqlStatement;
          await db.execute(sqlStatement);
        }

        // Mark as executed
        await markSqlMigrationExecuted(db, migration.hash!);
        logger.debug(`‚úÖ [${timestamp}] Completed SQL: ${migration.hash}\n`);
        sqlCount++;
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        const errorStack = error instanceof Error ? error.stack : undefined;

        // Store detailed error information for UI recovery
        lastMigrationError = {
          migrationHash: migration.hash,
          migrationFilename: `${migration.hash}.sql`,
          migrationType: "sql",
          timestamp,
          failedQuery: currentQuery,
          errorMessage,
          errorStack,
        };

        logger.error(`‚ùå [${timestamp}] Failed SQL: ${migration.hash}`);
        logger.error(`   Migration hash: ${migration.hash}`);
        logger.error(
          `   Failed query: ${currentQuery?.substring(0, 200)}${(currentQuery?.length || 0) > 200 ? "..." : ""}`,
        );
        logger.error(`   Error: ${errorMessage}`);
        if (errorStack) {
          logger.error(`   Stack: ${errorStack}`);
        }

        // Create detailed error message for UI
        const detailedError = [
          `Migration: ${migration.hash}`,
          `Query: ${currentQuery?.substring(0, 100)}${(currentQuery?.length || 0) > 100 ? "..." : ""}`,
          `Error: ${errorMessage}`,
        ].join("\n");

        onProgress?.("run-migrations", "error", detailedError);
        throw error; // SQL migrations should not fail
      }
    } else {
      logger.debug(
        `üìú [${timestamp}] Running TypeScript: ${migration.filename}`,
      );
      try {
        // Execute TypeScript migration
        await typescriptMigrations[migration.filename]();

        // Mark as executed
        await markTypescriptMigrationExecuted(db, migration.filename);
        logger.debug(
          `‚úÖ [${timestamp}] Completed TypeScript: ${migration.filename}\n`,
        );
        tsCount++;
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : String(error);
        const errorStack = error instanceof Error ? error.stack : undefined;

        // Store detailed error information
        lastMigrationError = {
          migrationFilename: migration.filename,
          migrationType: "typescript",
          timestamp,
          errorMessage,
          errorStack,
        };

        logger.error(
          `‚ùå [${timestamp}] Failed TypeScript: ${migration.filename}`,
        );
        logger.error(`   Error: ${errorMessage}`);
        if (errorStack) {
          logger.error(`   Stack: ${errorStack}`);
        }
        // Don't throw - allow app to continue even if TypeScript migration fails
        logger.error("   ‚ö†Ô∏è  Migration failed but continuing...\n");
      }
    }
  }

  onProgress?.("run-migrations", "success");

  logger.debug("‚ú® All migrations complete!\n");
  logger.debug("üìä Migration Summary:");
  logger.debug(`   SQL migrations executed: ${sqlCount}`);
  logger.debug(`   TypeScript migrations executed: ${tsCount}`);
  logger.debug(`   Total: ${sqlCount + tsCount}\n`);
}

/**
 * Get migration status (for debugging)
 */
export async function getMigrationStatus(): Promise<{
  sql: Array<{ hash: string; created_at: Date }>;
  typescript: Array<{ filename: string; executed_at: Date }>;
}> {
  const db = await Drizzle.getInstance();
  await ensureMigrationInfrastructure(db);

  // Get SQL migration status
  const sqlResult = await db.execute(sql`
    SELECT hash, created_at
    FROM ${sql.identifier(DRIZZLE_MIGRATION_SCHEMA)}.${sql.identifier(DRIZZLE_MIGRATION_TABLE)}
    ORDER BY created_at DESC
  `);

  // Get TypeScript migration status
  const tsResult = await db.execute(sql`
    SELECT filename, executed_at
    FROM ${sql.identifier(DATA_MIGRATION_TABLE)}
    ORDER BY executed_at DESC
  `);

  return {
    sql: sqlResult.rows as Array<{ hash: string; created_at: Date }>,
    typescript: tsResult.rows as Array<{ filename: string; executed_at: Date }>,
  };
}
